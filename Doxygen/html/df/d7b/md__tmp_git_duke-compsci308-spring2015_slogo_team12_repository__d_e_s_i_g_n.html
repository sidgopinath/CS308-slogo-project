<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>slogo_team12: Introduction</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">slogo_team12
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Packages</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The SLogo program will allow users to input commands into a graphical user interface to move and manipulate an on-screen turtle in a way very similar to the Logo programming language primarily used for educational purposes. As we proceed with the coding of the program, we have several design goals we want to keep in mind for the project. This is a program that should be able to be very easily extended. This is especially the case in terms of instructions and the Turtle itself. Our program needs to be very flexible in how instructions are handled and how the Turtle is represented on-screen. Our "parser" that reads in user input needs to allow for many variations and possible future extensions.</p>
<p>The primary architecture of the design is very directly inspired by those design goals. We want to keep the controller rather closed, as it handles interactions between the view and the model. The basic layout of an instruction and the parser should also stay relatively closed. However, we want to easily leave the program open to more additions in terms of instructions or how the user interacts with the turtle on the view side and the back-end. We also want the Turtle object to be somewhat open, in the sense that additional parameters could be added if need be.</p>
<h2>Overview</h2>
<div class="image">
<img src="http://i.imgur.com/fPicHLX.jpg"  alt="Diagram"/>
</div>
<p>Our SLogo implementation is centered around a model-view-controller design. We create a Main class, which handles instantiation of the Stage, the View, and the Controller, and the Model. SLogoController is the controller that handles user input, SLogoModel is the model that translates user input into instructions on how to update the view, and SLogoView is the view to update the display. SLogoController will have access to the instance of SLogoModel. SLogoModel will have access to an instance of SLogoView, and SLogoView will have access to an instance of SLogoController. Therefore, the flow of the program is always user &ndash;&gt; controller &ndash;&gt; model &ndash;&gt; view. This helps each part of the design remain distinct while also helping the other parts, and it also creates the basic framework upon which our SLogo interpreter is built.</p>
<p>Specifically, the view is created first and will take in information from the user as text is input in the textbox and as selections in the history, variable, or customization option panels. This information will then be transferred to the controller. This prevents the view from needing direct access to the Model. The view also has an constructor that takes in a Stage object. Main will then call view.init(), which will create a new Scene with all the UI elements included and also set the scene to the stage.</p>
<p>From here, the model is instantiated and passed the view as an argument. The model holds all data about the scene that is currently being displayed - the instance(s) of the Turtle object that describe the turtle, the functions and variables the user has defined, and the parser that is used to process commands. This parser will work with an abstraction hierarchy of instructions, with each "type" of instruction having its own class - for example, forward and backward can be grouped as one instruction type, since backward is really just a reverse forward command. All communication between the controller and the model happens through the parser method, which takes in a string and instantiates the correct instruction type. All math operations/boolean values are evaluated by a pre-parser, which transforms these operands into primitive values (true, false, integers). After complex expressions have been removed, this string is then passed to the parser and used to instantiate the correct command object. All instructions contain a .execute method, which runs the instruction and either a) returns an Instruction object containing the new turtle state, b) adds an entry to the map representing variables, or c) adds an entry to the map representing functions. This design is easily extendable - any new instruction can simply subclass command and return a new type, or can add a new field to the instruction class. A list of all instruction objects executed returned in this series of instructions is then passed to the view, which uses the data it contains to draw the lines and populate the history. This implementation is flexible, as it allows more than one instruction to be executed at a time by the user. It also allows for the potential for multiple turtles to be on screen and updated at once, since the instruction class specifies the turtle that will be updated through the id field.</p>
<p>Then Main instantiate the controller. The controller has all the methods that handle user input. For example, the controller will have a method that passes the commands in the command window to model as a single String when the run button is clicked. After the controller is created, Main passes the controller back to the view, which accesses specific methods in the controller through corresponding lambda functions. This is the only time when the view has access to the controller.</p>
<p>This design ensures extensibility. When a new interactive UI element is added, one only needs to create a method that handles this element in SLogoController. This method will be automatically added to a lamda function in SLogoView, because both the UI element and the method will follow a strict naming scheme. This method will then use the SLogoModel APIs to pass information to SLogoModel. When one adds a new command to the model, he/she only has to update the SLogoModel class to have a new set of rules to translate the command into instructions to update the view or perform certain algorithms. How the model obtains information from the controller or how it communicates with the view remain the same.</p>
<h3>Components:</h3>
<ul>
<li>Main:<ul>
<li>instantiates front-end, back-end, and controller</li>
</ul>
</li>
<li>SLogoController:<ul>
<li>monitors user input</li>
<li>passes user commands to SLogoModel</li>
</ul>
</li>
<li>SLogoModel:<ul>
<li>Contains all backend data, including instances of the turtle object. Also contains the instruction parser.</li>
</ul>
</li>
<li>SLogoView:<ul>
<li>Initialize UI.</li>
<li>Receive a list of instructions from SLogoModel to update the display.</li>
<li>Reset the display when requested.</li>
</ul>
</li>
<li>Some utility classes:<ul>
<li>Instruction: contains instructions to update the turtles. It is always instantiated by SLogoModel, and passed to SLogoView.</li>
<li>Polar: contains a pair of polar coordinates.</li>
<li>Turtle: A class which contains the state objects for a specific turtle - its current position, whether the pen is down, its heading, and whether the turtle is showing or not. This class does not have many</li>
<li>Drawer: translate Instruction to a PolyLine object. Returns false if the Instruction is to turn the turtle (distance == 0).</li>
</ul>
</li>
</ul>
<h2>User Interface</h2>
<p>In the scene, the user will be able to see the display containing the turtle in the main pane. Below it will be a textbox where the user can interactively enter a number of Logo commands. By clicking run, the IDE will run, parse and compile the code, and change the display by moving the turtle and drawing lines. After clicking run, the text in the box will automatically be erased and provide a blank slate for the user to enter in new commands. Additionally, any changed or inputted variables will appear on the right side bar with current values. A history of the strings written and run will remain in the History box also within the right side pane.</p>
<p>The right side pane will function as a menu for the user, giving the user access to visualization customization and also to details on current variables and previous commands (history). In customization, the user will be able to select an image file for the turtle (which will be resized to fit a size preset by the IDE), select and change the pen color (via a choice box), and select and change the background color (via a choice box).</p>
<p>The turtle will be defaulted to a green triangle in the center (0,0) of the display. As it moves, lines will be drawn connecting it to its new and final values/points.</p>
<p>An example of the user interface can be seen below </p><div class="image">
<img src="http://i.imgur.com/YJuOLaO.jpg"  alt="UI"/>
</div>
<p>The user interface will also alert the user to general errors during compilation. Each error will appear as a popup box.</p>
<ul>
<li>If the user presses "run" without specifying commands, the user will receive an error "Please specify a command"</li>
<li>If the user enters in a command that the parser does not recognize, the user will receive an error "Command not found: ______" with the specific erroneous command</li>
<li>If the user enters in a command whose syntax the parser does not recognize, the user will receive an error of "Invalid syntax"</li>
<li>If there is a math error (ie. user tries to divide by 0), the user will receive a "Math Exception" error</li>
</ul>
<h2>Design Details</h2>
<p>When Main instantiates the components, it follows this specific order: SLogoView, SLogoModel(SLogoView), SLogoController(SLogoModel). Then Main calls the setController method in SLogoView to bind the lambda functions in SLogoController to UI elements. When the user types in some commands and clicks run, SLogoController will send the commands as a single String to SLogoModel. SLogoModel then interprets the commands, and translate them into a List of Instruction objects. The Instruction class contains the information that SLogoView needs to update the display, for example, an integer to specify the ID of the turtle to be updated, a set of polar coordinates to specify the movement of the turtle, a boolean variable to specify pen-up or pen-down. The polar coordinates will be stored in instances of the Polar class, which has two variables: distance and angle. Angle varies from 0 to 360, corresponding to the angle from the vector to north (always CCW). If distance is 0, then the turtle turns around its own axis to the angle specified by Angle; otherwise, the turtle moves without turning. For example, (60,90) means move the turtle 60 pixels east. (0,180) means to turn the turtle so that it faces south. SLogoModel then calls SLogoView.update(List&lt;Instruction&gt; instructions), which loops through the List of Instructions, and move the specified turtle accordingly.</p>
<h3>SLogoView:</h3>
<p>Besides update(), SLogoView has the following public methods:</p><ul>
<li>init(): initialize the view and create all UI elements. Each element will have a unique ID. All interactive elements will be stoerd in a Map&lt;Integer, Node&gt; called interactives.</li>
<li>clear(): re-initialize the view. All current drawings will be cleared, and one turtle will start at the origin.</li>
<li>setController(Controller controller): bind the controller to UI elements.</li>
<li>addTurtle(int ID): create a new turtle using a user specified image.</li>
</ul>
<h3>SLogoModel:</h3>
<p>The SLogo model contains all data needed to parse and run SLogo commands. The instances of the turtle objects are contained here, as well as the code parser and all state information about the view (if the pen is down, etc.) At a lower level, this class contains methods to parse the individual instructions, as well as an abstract class Command that all other commands inherit from. To extend a command, one simply adds a new class that inherits from command and implements its .execute method to tell the parser what need to be updated. In the .parse method, the command's string needs to be added, and a call to view.update() made if the command impacts the view. Further, this design inherently supports multiple turtles. When a turtle is added, the method .addNewTurtle() is called by the controller. This then calls a method in the view which notifies the view of a new turtle, and prompts it to ask for an image file for the turtle. No extension beyond new commands and support for multiple turtles is currently available - however, support could be added by adding methods to be called by the controller that do specific tasks. Having the model contain all state information and only communicating changes to the Turtle to the view minimizes data passed between classes, and helps greatly with encapsulation.</p>
<h3>SLogoController:</h3>
<p>The SLogoController has all the methods that handle user input. These methods are named according to the following scheme: handleUI[id]. For example, the handleUI1 is called when the UI element 1 is clicked.</p>
<h2>API Example Code</h2>
<p><em>The user types 'fd 50' in the command window, and sees the turtle move in the display window leaving a trail.</em></p>
<p>After the users finish typing the command in the command window, they click a button/press enter in the window. This button's onClick() method is called, which is a lambda expression that calls the Controller Object's .parse(String s) with the string typed into the box by the user as the argument s. The controller then calls the model's .parse(String s) method, which uses a regular expression to split the string into a command format. From here, a specific Command object will be instantiated depending on which command is called - commands that do not need to update the turtle/turtle's position will be treated differently than commands which update the model, i.e. creating variables. In this case, a Forward object will be instantiated, whose .execute() method will be called to update the turtle's position. The .execute method returns a Instruction object, which contains the specific turtle's unique id, a Polar object, and a boolean to specify whether the pen was down. This Instruction object is returned to model.parse(), which adds the Instruction object to a list of Instruction objects. The model.parse() method calls view.update(list&lt;Instruction&gt;) with the newly created list.</p>
<p>[User types in values in a text field within the display. The user then clicks run] View.Button.onClick() -&gt; Model.parse(String s) and call HistoryView.update() Model.parse(String s) returns a Forward object (which extends the Command object) Forward.execute() updates the turtle object and returns an Instruction object to the model and thus to the controller</p>
<ul>
<li>Grid.getLength() (get grid dimensions to properly update toroidal effects)</li>
<li>Grid.getWidth()</li>
<li>Turtle.getLocation()</li>
<li>Turtle.getHeading()</li>
<li>Turtle.getStart()</li>
<li>Turtle.setNewLocation()</li>
<li>Turtle.setNewHeading()</li>
<li>Turtle.setNewStart() View.updateGrid(List&lt;Instruction&gt;)</li>
<li>Line.getColor()</li>
<li>Grid.drawLine(startPoint, endPoint)</li>
<li>ImageView.setRotate() (the turtle in the view is represented by an ImageView)</li>
<li>ImageView.setTranslateX()</li>
<li>ImageView.setTranslateY()</li>
</ul>
<p>VariableView.update()</p>
<h2>Design Considerations</h2>
<p>In the initial design of Slogo, we considered several different possibilities of information flow between the back-end and the front-end.</p>
<ol type="1">
<li>In one of the first possibilities that we considered, Main would call a controller which would call the front and back ends. To pass information between front and back, both sides would contain Turtle a turtle object containing the functionality and properties of a turtle. This method would allow us to be able to keep track of the turtle's location, header/direction, and other properties in both the front and back end and allow both to be able to move and change the objects. However, in order to transfer information between these, a Turtle object (or a TurtleState object containing almost the exact same information minus a few properties that may not be needed) would be passed through the controller to update both turtles. This flow of information seemed to work but also brought the problem increased the number of places with the exact same information (duplicated code) and would also give both sides access to almost the exact same object (but initialized separately), which did not seem to be an ideal decision. A turtle would be updated once, then a turtle state would be created containing almost exactly the same information, and then it would be passed into the front end where yet another turtle would be updated.</li>
<li>We decided that it would be best to leave the turtle object in full control by either the front-end or back-end and simply pass information into another portion. We initially designed our project so that the turtles would remain in the front end; however, this was not an ideal decision because the Turtle would have access to data/information that the back-end utilized/updated. The front-end and back end would be too dependent and linked upon each other.</li>
<li>As a solution to the above problem, we decided to place the Turtle into the back-end. In essence, the user would type a command, and the View would pass in the string to the Model via the controller. The Model would update the turtle object and store a list of Instruction objects containing start and end coordinates (so that a line could be drawn in the View), a boolean detailing whether the pen is up or down based on the current command, whether or not the turtle is showing, and any other information such as variables that the View may need to display. Doing so this way limited the amount of information the View received (it would only receive what was necessary) and limit its access to the Turtle or other Model components.</li>
<li>We still need to develop a better method for implementing commands in the backend. Ideally, there will be no need for if-else structures to determine a command and call the appropriate command subclass. Even if these structures are necessary, we can better develop the command abstraction hierarchy so that it is easier to extend. Since commands seem to either impact the turtle or the model, this may be a logical distinction for how we divide our classes.</li>
<li>When deciding how to implement the model, we debated what sort of object should be passed to the view extensively. We wanted to pass as little as possible while still allowing the view to work - we considered passing a completed polyline, but realized this was too complete and would not allow the view to not draw certain sections if the pen was not down. Instead, we passed in a series of coordinates along with a turtle id (for multiple turtle cases) and a boolean for if the view should draw those coordinates. <h2>Team Responsibilities</h2>
</li>
</ol>
<p>Greg - Work primarily on backend, implementing parser for instructions and Turtle object. Secondary - help Callie with GUI</p>
<p>Sid - Back-end work. Helps in implementation of Turtle object and instructions. Secondary role of helping Mengchao with the controller and Main, specifically with interactions between the Controller and Model.</p>
<p>Callie - The view and all user interface design</p>
<p>Mengchao - Controller and interaction between view and controller </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 20 2015 21:27:54 for slogo_team12 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
